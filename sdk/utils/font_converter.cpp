#include <platform.h>
#include <platform/args.h>

#include "assets_utils.h"

/** Takes font in ttf or otf format and produces font glyphs from it. 
 
    Usage: 

        font-converter FONT_FILE OUTPUT_FILE FONT_SIZE [ --glyphs GLYPH_FILE ] [--namespace NAMESPACE]

 */
int main(int argc, char const * argv[]) {
    Args::Arg<std::string> inputFile{""};
    Args::Arg<std::string> outputFile{""};
    Args::Arg<unsigned> fontSize{16};
    Args::Arg<std::string> glyphs{"glyphs", ""};
    Args::Arg<std::string> ns{"namespace", "rckid::assets"};
    Args::parse(argc, argv, { inputFile, outputFile, fontSize, glyphs, ns});
    // get the glyphs 
    Glyphs fontGlyphs = glyphs.isDefault() ? getDefaultGlyphs() :  loadGlyphIndices(glyphs.value());
    GlyphInfo * ginfos = loadFontGlyphs(inputFile.value(), fontSize.value(), fontGlyphs);
    // and output them
    std::ofstream ofile{outputFile.value()};
    if (!ofile.good())
        throw std::runtime_error(STR("Unable to open output file " << outputFile.value()));
    generateAssetsFileHeader(argc, argv, ofile);
    ofile << "#include <rckid/graphics/font.h>" << std::endl<< std::endl;
    std::string indent = "";
    if (! ns.value().empty()) {
        ofile << "namespace " << ns.value() << " {" << std::endl << std::endl;
        indent = "    ";
    }
    // process font glyphs into glyphinfo and raw pixel arrays
    std::stringstream pixelData;
    std::stringstream glyphData;
    size_t pixelOffset = 0;
    for (size_t i = 0, e = fontGlyphs.size(); i < e; ++i) {
        std::string comment = STR("// " << i << ": '" << fontGlyphs.names[i] << "', codepoint " << fontGlyphs.codepoints[i] << ", utf8: " << encodeUTF8(fontGlyphs.codepoints[i]) << ", pixel offset " << pixelOffset);
        glyphData << indent << "        GlyphInfo{" 
                        << pixelOffset << ", " 
                        << ginfos[i].advanceX << ", "
                        << ginfos[i].offsetX << ", "
                        << ginfos[i].offsetY << ", "
                        << ginfos[i].image.width << ", "
                        << ginfos[i].image.height 
                        << "}, " << comment << std::endl;
        drawImageInComments(ginfos[i].image, glyphData, indent + "        ");
        pixelData << std::endl << indent << "        " << comment << std::endl << indent << "        ";
        pixelOffset += outputImageAsFontGlyph(ginfos[i].image, pixelData);
    }
    // deal with the font output
    std::string className = convertToClassName(STR(std::filesystem::path{inputFile.value()}.stem().string() << fontSize.value()));
    ofile << indent << "/* Autogenerated font." << std::endl << std::endl;
    ofile << indent << "   Filename: " << inputFile.value() << std::endl;
    ofile << indent << "   Size:     " << fontSize.value() << std::endl;
    ofile << indent << "   Glyphs:   " << fontGlyphs.size() << std::endl;
    ofile << indent << "   Glyphs size: " << (fontGlyphs.size() * 8) << std::endl;
    ofile << indent << "   Pixels size: " << pixelOffset << std::endl;
    ofile << indent << "   Total size:  " << (pixelOffset + fontGlyphs.size() * 8) << std::endl;
    ofile << indent << " */" << std::endl;
    ofile << indent << "class " << className << " {" << std::endl;
    ofile << indent << "public:" << std::endl;
    ofile << indent << "    static constexpr int size = " << fontSize.value() << ";" << std::endl << std::endl;
    ofile << indent << "    static constexpr GlyphInfo glyphs[] = {" << std::endl;
    ofile << glyphData.str();
    ofile << indent << "    }; // " << className << "::glyphs" << std::endl << std::endl;
    ofile << indent << "    static constexpr uint8_t pixels[] = {"; // endl from pixels
    ofile << pixelData.str() << std::endl;
    ofile << indent << "    }; // " << className << "::pixels" << std::endl;
    ofile << indent << "}; // class " << ns.value() << "::" << className << std::endl;
    if (! ns.value().empty())
        ofile << "} // namespace " << ns.value() << std::endl;
    return EXIT_SUCCESS;
}