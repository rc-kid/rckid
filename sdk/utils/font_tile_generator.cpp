#include <platform.h>
#include <platform/args.h>

#include "assets_utils.h"


/** Draws given image centered to a tile of given sizes using the tile constructor macros. 
 */
inline void drawTileConstructor(GlyphInfo & gi, unsigned w, unsigned h, std::ostream & s, std::string const & indent, uint32_t bpp) {
    // determine the X and Y offsets of the glyphinfo image inside the tile
    // TODO
    int offsetX = (w - gi.image.width) / 2;
    int offsetY = (h - gi.image.height) / 2;
    s << indent << "Tile<" << w << "," << h << "," << bpp << ">{{" << "\n";
    for (int y = 0; y < h; ++y) {
        s << indent << "    ";
        for (int x = 0; x < w; ++x) {
            unsigned value = 0;
            // if we are inside a glyph, take from glyph
            if (y >= offsetY && y < offsetY + gi.image.height && x >= offsetX && x < offsetX + gi.image.width) {
                Color cc = GetImageColor(gi.image, x - offsetX, y - offsetY);
                // get the color and fix it for BPP, convert to 4bpp
                unsigned c = (cc.r + cc.g + cc.b) / 3;
                value = std::min(255u, c + 8); // rounding 
                value >>= 4;
            }
            // TODO print the value
            if (value == 0)
                s << "__, ";
            else if (value < 10)
                s << " " << value << ", ";
            else
                s << value << ", ";
        }
        s << "\n";
    }
    s << indent << "}},\n";
    
}

/** Takes font in ttf or otf format and creates from it tiles of given width and height. 
 
    Usage:

        font-tile-generator FONT_FILE OUTPUT_FILE FONT_SIZE TILE_WIDTH TILE_HEIGHT [ --glyphs GLYPH_FILE ] [--namespace NAMESPACE]
 */

int main(int argc, char const * argv[]) {
    Args::Arg<std::string> inputFile{""};
    Args::Arg<std::string> outputFile{""};
    Args::Arg<unsigned> fontSize{16};
    Args::Arg<unsigned> tileWidth{16};
    Args::Arg<unsigned> tileHeight{16};
    Args::Arg<std::string> glyphs{"glyphs", ""};
    Args::Arg<std::string> ns{"namespace", "rckid::assets"};
    Args::Arg<unsigned> bpp{"bpp", 8};
    Args::parse(argc, argv, { inputFile, outputFile, fontSize, tileWidth, tileHeight, glyphs, ns, bpp});
    // get the glyphs 
    Glyphs fontGlyphs = glyphs.isDefault() ? getDefaultGlyphs() :  loadGlyphIndices(glyphs.value());
    GlyphInfo * ginfos = loadFontGlyphs(inputFile.value(), fontSize.value(), fontGlyphs);
    // and output them
    std::ofstream ofile{outputFile.value()};
    if (!ofile.good())
        throw std::runtime_error(STR("Unable to open output file " << outputFile.value()));
    generateAssetsFileHeader(argc, argv, ofile);
    ofile << "#include <rckid/graphics/tile.h>" << std::endl<< std::endl;
    std::string indent = "";
    if (! ns.value().empty()) {
        ofile << "namespace " << ns.value() << " {" << std::endl << std::endl;
        indent = "    ";
    }
    ofile << indent << "/* Autogenerated font tiles." << std::endl << std::endl;
    ofile << indent << "   Filename:       " << inputFile.value() << std::endl;
    ofile << indent << "   Font size:      " << fontSize.value() << std::endl;
    ofile << indent << "   Tile width:     " << tileWidth.value() << std::endl;
    ofile << indent << "   Tile height:    " << tileHeight.value() << std::endl;
    ofile << indent << "   Tile bpp:       " << bpp.value() << std::endl;
    ofile << indent << "   tiles:          " << fontGlyphs.size() << std::endl;
    ofile << indent << " */" << std::endl;
    std::string className = convertToClassName(STR(std::filesystem::path{inputFile.value()}.stem().string() << fontSize.value()));
    ofile << indent << "static constexpr Tile<" << tileWidth.value() << "," << tileHeight.value() << "," << bpp.value() << "> " << className << "[] = {" << std::endl;     
    ofile << indent << "#define __ 0" << std::endl;
    
    for (size_t i = 0, e = fontGlyphs.size(); i < e; ++i) {
        ofile << indent << "// " << i << ": '" << fontGlyphs.names[i] << "', codepoint " << fontGlyphs.codepoints[i] << ", utf8: `" << encodeUTF8(fontGlyphs.codepoints[i]) << "`\n";
        drawTileConstructor(ginfos[i], tileWidth.value(), tileHeight.value(), ofile, indent, bpp.value());
    }

    ofile << indent << "#undef __" << std::endl;
    ofile << indent << "};" << std::endl;
    if (! ns.value().empty())
        ofile << "} // namespace " << ns.value() << std::endl;
    return EXIT_SUCCESS;
}